package main

import (
	"context"
	"encoding/json"
	"io"
	"testing"
)

type TestMsgType struct {
	Foo string `json:"foo"`
}

type TestReader struct {
	t      *testing.T
	Bytes  []byte
	Offset *int
}

func (r TestReader) Read(b []byte) (n int, err error) {
	if *r.Offset < len(r.Bytes) {
		n = copy(b, r.Bytes[*r.Offset:])
		*r.Offset = *r.Offset + n
	}
	if *r.Offset == len(r.Bytes) {
		err = io.EOF
	}
	return
}

func TestTestReader(t *testing.T) {
	tstRawMsg := []byte(`abcdefg`)
	r := TestReader{t, tstRawMsg, new(int)}
	tbuf := make([]byte, 7)

	n, err := r.Read(tbuf)
	if n != len(tbuf) {
		t.Errorf("Expeced readed length to be %d, got %d", len(tbuf), n)
	}
	if err != io.EOF {
		t.Errorf("Expected io.EOF, got %#v", err)
	}
}

func TestMessage(t *testing.T) {
	m := NewMessage("someType", &TestMsgType{"lol"})
	packed, err := m.Pack()
	t.Logf("%#v\n", packed)
	if err != nil {
		t.Error("Expeced no error from m.Pack()")
	}

	var unpackedMsg Message

	err = json.Unmarshal(packed[4:], &unpackedMsg)
	t.Logf("%s\n", unpackedMsg.Payload)
}

func TestReadMessage(t *testing.T) {
	// tstRawMsg = {type: "someType", payload: "{\"foo\": \"bar\"}"}
	// tstRawMsg length == 52
	tstRawMsg := []byte{0x34, 0x0, 0x0, 0x0, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x6f, 0x6d, 0x65, 0x54, 0x79, 0x70, 0x65, 0x22, 0x2c, 0x22, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x22, 0x3a, 0x22, 0x65, 0x79, 0x4a, 0x6d, 0x62, 0x32, 0x38, 0x69, 0x4f, 0x69, 0x4a, 0x73, 0x62, 0x32, 0x77, 0x69, 0x66, 0x51, 0x3d, 0x3d, 0x22, 0x7d}

	r := TestReader{t, tstRawMsg, new(int)}

	msg, err := ReadMessage(r)
	if err != nil {
		t.Errorf("Unexpedted error reading message - %s", err.Error())
	}
	if msg.Type != "someType" {
		t.Errorf("Expected msg.Type to be %q, got %q", "someType", msg.Type)
	}
}

func TestMessageStreamReader(t *testing.T) {
	tstRawMsg := []byte{0x34, 0x0, 0x0, 0x0, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x6f, 0x6d, 0x65, 0x54, 0x79, 0x70, 0x65, 0x22, 0x2c, 0x22, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x22, 0x3a, 0x22, 0x65, 0x79, 0x4a, 0x6d, 0x62, 0x32, 0x38, 0x69, 0x4f, 0x69, 0x4a, 0x73, 0x62, 0x32, 0x77, 0x69, 0x66, 0x51, 0x3d, 0x3d, 0x22, 0x7d, 0x34, 0x0, 0x0, 0x0, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x6f, 0x6d, 0x65, 0x54, 0x79, 0x70, 0x65, 0x22, 0x2c, 0x22, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x22, 0x3a, 0x22, 0x65, 0x79, 0x4a, 0x6d, 0x62, 0x32, 0x38, 0x69, 0x4f, 0x69, 0x4a, 0x73, 0x62, 0x32, 0x77, 0x69, 0x66, 0x51, 0x3d, 0x3d, 0x22, 0x7d}
	r := TestReader{t, tstRawMsg, new(int)}

	msgStreamCtx, closeMsgStream := context.WithCancel(context.Background())
	streamReader := NewMessageStream(msgStreamCtx, r)

	for i := 0; i < 2; i++ {
		msg := <-streamReader
		if msg.Type != "someType" {
			t.Errorf("Invalid message type (malformed message): %#v", *msg)
		}
	}
	closeMsgStream()

}
